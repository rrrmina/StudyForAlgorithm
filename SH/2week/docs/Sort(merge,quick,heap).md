# __Sort (merge, quick, heap)__

## - _병합 정렬(MergeSort)_
* 병합 정렬   
먼저 입력을 반으로 나눈다. 이렇게 나눈 전반부와 후반부를 각각 독립적으로 정렬한다.  
마지막으로 정렬된 두 부분을 병합하여 정렬된 리스트를 얻는다.  
여기서 각 전반부와 후반부를 정렬할 때에도 역시 반으로 나눈 다음 정렬해서 병합한다.  
이러한 작업을 재귀적으로 반복한다.

* 로직
```python
 mergeSort(A[], p, r):  # A[p...r] 정렬
    if (p < r)
        1️⃣ q <- |(p+r)/2|  # p, r 중간 지점 계산    
        2️⃣ mergeSort(A, p, q)  # 전반부 정렬
        3️⃣ mergeSort(A, q+1, p)  # 후반부 정렬
        4️⃣ merge(A, p, q, r)  # 병합

 merge(A[], p, q, r):
    정렬된 두 리스트 A[p...q]와 A[q+1...r]을 합쳐
    정렬된 하나의 리스트 A[p...r]을 만든다.
 ```

 * 시간 복잡도  
 최악, 평균, 최선의 모든 경우에 Θ(nlogn)이다.  
 <br>
## - _퀵 정렬(QuickSort)_
* 퀵 정렬  
병합 정렬이 먼저 재귀적으로 작은 문제를 해결한 다음 후처리를 하는 데 반해, 퀵 정렬은 선행 작업을 한 다음 재귀적으로 작은 문제를 해결하면서 바로 끝난다.  
퀵 정렬은 기준 원소를 하나 잡아 기준 원소보다 작은 원소와 큰 원소 그룹으로 나누어 기준 원소의 좌우로 분할한 다음 각각을 정렬하는 방법이다.

* 로직  
```python
 quickSort(A[], p, r):  # A[p...r]을 정렬한다.
    1️⃣if (p < r)
        2️⃣ q <- partition(A, p, r)  # 분할
        3️⃣ quickSort(A, p, q-1)  # 왼쪽 부분 리스트 정렬
        4️⃣ quickSort(A, q+1, p)  # 오른쪽 부분 리스트 정렬

 partition(A[], p, r):
    x <- A[r]  # 기준 원소
    i <- p-1  # i는 1구역의 끝 지점
    for j <- p to r-1  # j는 3구역의 시작 지점
        if (A[j] < x)
            A[++i] <-> A[j]  # i값 증가 후 A[i]와 A[j]를 교환한다.
    A[i+1] <-> A[r]  #기준 원소와 2구역 첫 원소를 교환한다.
    return i + 1
```

* 시간 복잡도  
평균 : Θ(nlogn)  
최악 : Θ(n<sup>2</sup>)  
<br>

## - _힙 정렬(HeapSort)_
* 힙 정렬  
힙 자료구조를 사용하여 정렬한다. 리스트 A[0...n-1]이 주어지면   
힙을 만든 후, 원소를 하나 씩 제거하면서 수선해주면 된다.

* 로직
```python
 heapSort():
    buildHeap()
    for i <- n-1 downto 1
        A[i] <- deleteMax()
```
* 시간 복잡도  
수행 시간: O(nlogn)  
최선 : Θ(n)  
최악 : Θ(nlogn)